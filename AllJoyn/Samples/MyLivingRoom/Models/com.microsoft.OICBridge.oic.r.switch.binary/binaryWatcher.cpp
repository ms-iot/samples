//-----------------------------------------------------------------------------
// <auto-generated> 
//   This code was generated by a tool. 
// 
//   Changes to this file may cause incorrect behavior and will be lost if  
//   the code is regenerated.
//
//   Tool: AllJoynCodeGenerator.exe
//
//   This tool is located in the Windows 10 SDK and the Windows 10 AllJoyn 
//   Visual Studio Extension in the Visual Studio Gallery.  
//
//   The generated code should be packaged in a Windows 10 C++/CX Runtime  
//   Component which can be consumed in any UWP-supported language using 
//   APIs that are available in Windows.Devices.AllJoyn.
//
//   Using AllJoynCodeGenerator - Invoke the following command with a valid 
//   Introspection XML file and a writable output directory:
//     AllJoynCodeGenerator -i <INPUT XML FILE> -o <OUTPUT DIRECTORY>
// </auto-generated>
//-----------------------------------------------------------------------------
#include "pch.h"
#include <memory>

using namespace concurrency;
using namespace Microsoft::WRL;
using namespace Platform;
using namespace Windows::Foundation;
using namespace Windows::Devices::AllJoyn;
using namespace com::microsoft::OICBridge::oic::r::Switch::binary;
using namespace std;

binaryWatcher::binaryWatcher(AllJoynBusAttachment^ busAttachment) :
    m_aboutListener(nullptr)
{
    m_busAttachment = busAttachment;
    m_weak = new WeakReference(this);
    m_busAttachmentStateChangedToken.Value = 0;
}

binaryWatcher::~binaryWatcher()
{
    UnregisterFromBus();
}

void binaryWatcher::UnregisterFromBus()
{
    if (nullptr != m_aboutListener)
    {
        PCSTR interfaces[] = { "com.microsoft.OICBridge.*oic.r.switch.binary" };
        alljoyn_busattachment_cancelwhoimplements_interfaces(
            AllJoynHelpers::GetInternalBusAttachment(m_busAttachment),
            interfaces,
            _countof(interfaces));

        alljoyn_busattachment_unregisteraboutlistener(AllJoynHelpers::GetInternalBusAttachment(m_busAttachment), m_aboutListener);
        alljoyn_aboutlistener_destroy(m_aboutListener);
        m_aboutListener = nullptr;
    }
    if ((nullptr != m_busAttachment) && (0 != m_busAttachmentStateChangedToken.Value))
    {
        m_busAttachment->StateChanged -= m_busAttachmentStateChangedToken;
    }
}

void binaryWatcher::OnAnnounce(
    _In_ PCSTR name,
    _In_ uint16_t version,
    _In_ alljoyn_sessionport port,
    _In_ alljoyn_msgarg objectDescriptionArg,
    _In_ const alljoyn_msgarg aboutDataArg)
{
    UNREFERENCED_PARAMETER(version);
    UNREFERENCED_PARAMETER(aboutDataArg);

    alljoyn_aboutobjectdescription objectDescription = alljoyn_aboutobjectdescription_create_full(objectDescriptionArg);

    if (alljoyn_aboutobjectdescription_hasinterface(objectDescription, "com.microsoft.OICBridge.*"))
    {
        unique_ptr<const char *>arrayOfPath = nullptr;
        // get number of bus object path
        size_t nbOfPath = alljoyn_aboutobjectdescription_getpaths(objectDescription, nullptr, 0);
        if (0 < nbOfPath)
        {
            arrayOfPath = unique_ptr<const char *>(new (nothrow) const char *[nbOfPath]);
            if (nullptr != arrayOfPath)
            {
                if (alljoyn_aboutobjectdescription_getpaths(objectDescription, arrayOfPath.get(), nbOfPath) > 0)
                {
                    bool bFound = false;
                    for (size_t iPath = 0; iPath < nbOfPath && !bFound; iPath++)
                    {
                        const char* temp = arrayOfPath.get()[iPath];
                        // get number of bus interface the bus object implements
                        size_t nbOfInterfaces = alljoyn_aboutobjectdescription_getinterfaces(objectDescription, arrayOfPath.get()[iPath], nullptr, 0);
                        if (0 < nbOfInterfaces)
                        {
                            auto arrayOfInterfaces = unique_ptr<const char *>(new (nothrow) const char *[nbOfInterfaces]);
                            if (nullptr != arrayOfInterfaces)
                            {
                                if (alljoyn_aboutobjectdescription_getinterfaces(objectDescription, arrayOfPath.get()[iPath], arrayOfInterfaces.get(), nbOfInterfaces) > 0)
                                {
                                    for (size_t iBusInterface = 0; iBusInterface < nbOfInterfaces; iBusInterface++)
                                    {
                                        if (string(arrayOfInterfaces.get()[iBusInterface]).find("oic.r.switch.binary") != string::npos)
                                        {
                                            AllJoynServiceInfo^ args = ref new AllJoynServiceInfo(
                                                AllJoynHelpers::MultibyteToPlatformString(name),
                                                AllJoynHelpers::MultibyteToPlatformString(arrayOfPath.get()[iPath]),
                                                port);
                                            m_objectInterfaceName = arrayOfInterfaces.get()[iBusInterface];
                                            Added(this, args);

                                            bFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    alljoyn_aboutobjectdescription_destroy(objectDescription);
}

void binaryWatcher::BusAttachmentStateChanged(_In_ AllJoynBusAttachment^ sender, _In_ AllJoynBusAttachmentStateChangedEventArgs^ args)
{
    if (args->State == AllJoynBusAttachmentState::Connected)
    {
        alljoyn_aboutlistener_callback callbacks = 
        {
            AllJoynHelpers::AnnounceHandler<binaryWatcher>
        };
        m_aboutListener = alljoyn_aboutlistener_create(&callbacks, m_weak);

        alljoyn_busattachment_registeraboutlistener(AllJoynHelpers::GetInternalBusAttachment(sender), m_aboutListener);
        PCSTR interfaces[] = { "com.microsoft.OICBridge.*oic.r.switch.binary" };
        
        auto status = alljoyn_busattachment_whoimplements_interfaces(
            AllJoynHelpers::GetInternalBusAttachment(sender), 
            interfaces,
            _countof(interfaces));
        if (ER_OK != status)
        {
            StopInternal(status);
        }
    }
    else if (args->State == AllJoynBusAttachmentState::Disconnected)
    {
        StopInternal(ER_BUS_STOPPING);
    }
}

void binaryWatcher::Start()
{
    if (nullptr == m_busAttachment)
    {
        StopInternal(ER_FAIL);
        return;
    }

    m_busAttachmentStateChangedToken = m_busAttachment->StateChanged += ref new TypedEventHandler<AllJoynBusAttachment^, AllJoynBusAttachmentStateChangedEventArgs^>(this, &binaryWatcher::BusAttachmentStateChanged);
    m_busAttachment->Connect();
}

void binaryWatcher::Stop()
{
    StopInternal(AllJoynStatus::Ok);
}

void binaryWatcher::StopInternal(int32 status)
{
    UnregisterFromBus();
    Stopped(this, ref new AllJoynProducerStoppedEventArgs(status));
}