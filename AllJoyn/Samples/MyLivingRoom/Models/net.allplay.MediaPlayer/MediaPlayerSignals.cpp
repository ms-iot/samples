//-----------------------------------------------------------------------------
// <auto-generated> 
//   This code was generated by a tool. 
// 
//   Changes to this file may cause incorrect behavior and will be lost if  
//   the code is regenerated.
//
//   Tool: AllJoynCodeGenerator.exe
//
//   This tool is located in the Windows 10 SDK and the Windows 10 AllJoyn 
//   Visual Studio Extension in the Visual Studio Gallery.  
//
//   The generated code should be packaged in a Windows 10 C++/CX Runtime  
//   Component which can be consumed in any UWP-supported language using 
//   APIs that are available in Windows.Devices.AllJoyn.
//
//   Using AllJoynCodeGenerator - Invoke the following command with a valid 
//   Introspection XML file and a writable output directory:
//     AllJoynCodeGenerator -i <INPUT XML FILE> -o <OUTPUT DIRECTORY>
// </auto-generated>
//-----------------------------------------------------------------------------
#include "pch.h"

using namespace Microsoft::WRL;
using namespace Platform;
using namespace Windows::Devices::AllJoyn;
using namespace Windows::Foundation;
using namespace net::allplay::MediaPlayer;

void MediaPlayerSignals::Initialize(_In_ alljoyn_busobject busObject, _In_ alljoyn_sessionid sessionId)
{
    m_busObject = busObject;
    m_sessionId = sessionId;

    auto interfaceDefinition = alljoyn_busattachment_getinterface(alljoyn_busobject_getbusattachment(busObject), "net.allplay.MediaPlayer");
    alljoyn_interfacedescription_getmember(interfaceDefinition, "EnabledControlsChanged", &m_memberEnabledControlsChanged);
    alljoyn_interfacedescription_getmember(interfaceDefinition, "EndOfPlayback", &m_memberEndOfPlayback);
    alljoyn_interfacedescription_getmember(interfaceDefinition, "InterruptibleChanged", &m_memberInterruptibleChanged);
    alljoyn_interfacedescription_getmember(interfaceDefinition, "LoopModeChanged", &m_memberLoopModeChanged);
    alljoyn_interfacedescription_getmember(interfaceDefinition, "OnPlaybackError", &m_memberOnPlaybackError);
    alljoyn_interfacedescription_getmember(interfaceDefinition, "PlaylistChanged", &m_memberPlaylistChanged);
    alljoyn_interfacedescription_getmember(interfaceDefinition, "ShuffleModeChanged", &m_memberShuffleModeChanged);
}

void MediaPlayerSignals::EnabledControlsChanged(_In_ Windows::Foundation::Collections::IMapView<Platform::String^,bool>^ interfaceMemberEnabledControls)
{
    if (nullptr == m_busObject)
    {
        return;
    }

    size_t argCount = 1;
    alljoyn_msgarg arguments = alljoyn_msgarg_array_create(argCount);
    (void)TypeConversionHelpers::SetAllJoynMessageArg(alljoyn_msgarg_array_element(arguments, 0), "a{sb}", interfaceMemberEnabledControls);
    
    alljoyn_busobject_signal(
        m_busObject, 
        NULL,  // Generated code only supports broadcast signals.
        m_sessionId,
        m_memberEnabledControlsChanged,
        arguments,
        argCount, 
        0, // A signal with a TTL of 0 will be sent to every member of the session, regardless of how long it takes to deliver the message
        ALLJOYN_MESSAGE_FLAG_GLOBAL_BROADCAST, // Broadcast to everyone in the session.
        NULL); // The generated code does not need the generated signal message

    alljoyn_msgarg_destroy(arguments);
}

void MediaPlayerSignals::CallEnabledControlsChangedReceived(_In_ MediaPlayerSignals^ sender, _In_ MediaPlayerEnabledControlsChangedReceivedEventArgs^ args)
{
    EnabledControlsChangedReceived(sender, args);
}

void MediaPlayerSignals::EndOfPlayback()
{
    if (nullptr == m_busObject)
    {
        return;
    }

    size_t argCount = 0;
    alljoyn_msgarg arguments = alljoyn_msgarg_array_create(argCount);
    
    alljoyn_busobject_signal(
        m_busObject, 
        NULL,  // Generated code only supports broadcast signals.
        m_sessionId,
        m_memberEndOfPlayback,
        arguments,
        argCount, 
        0, // A signal with a TTL of 0 will be sent to every member of the session, regardless of how long it takes to deliver the message
        ALLJOYN_MESSAGE_FLAG_GLOBAL_BROADCAST, // Broadcast to everyone in the session.
        NULL); // The generated code does not need the generated signal message

    alljoyn_msgarg_destroy(arguments);
}

void MediaPlayerSignals::CallEndOfPlaybackReceived(_In_ MediaPlayerSignals^ sender, _In_ MediaPlayerEndOfPlaybackReceivedEventArgs^ args)
{
    EndOfPlaybackReceived(sender, args);
}

void MediaPlayerSignals::InterruptibleChanged(_In_ bool interfaceMemberInterruptible)
{
    if (nullptr == m_busObject)
    {
        return;
    }

    size_t argCount = 1;
    alljoyn_msgarg arguments = alljoyn_msgarg_array_create(argCount);
    (void)TypeConversionHelpers::SetAllJoynMessageArg(alljoyn_msgarg_array_element(arguments, 0), "b", interfaceMemberInterruptible);
    
    alljoyn_busobject_signal(
        m_busObject, 
        NULL,  // Generated code only supports broadcast signals.
        m_sessionId,
        m_memberInterruptibleChanged,
        arguments,
        argCount, 
        0, // A signal with a TTL of 0 will be sent to every member of the session, regardless of how long it takes to deliver the message
        ALLJOYN_MESSAGE_FLAG_GLOBAL_BROADCAST, // Broadcast to everyone in the session.
        NULL); // The generated code does not need the generated signal message

    alljoyn_msgarg_destroy(arguments);
}

void MediaPlayerSignals::CallInterruptibleChangedReceived(_In_ MediaPlayerSignals^ sender, _In_ MediaPlayerInterruptibleChangedReceivedEventArgs^ args)
{
    InterruptibleChangedReceived(sender, args);
}

void MediaPlayerSignals::LoopModeChanged(_In_ Platform::String^ interfaceMemberLoopMode)
{
    if (nullptr == m_busObject)
    {
        return;
    }

    size_t argCount = 1;
    alljoyn_msgarg arguments = alljoyn_msgarg_array_create(argCount);
    (void)TypeConversionHelpers::SetAllJoynMessageArg(alljoyn_msgarg_array_element(arguments, 0), "s", interfaceMemberLoopMode);
    
    alljoyn_busobject_signal(
        m_busObject, 
        NULL,  // Generated code only supports broadcast signals.
        m_sessionId,
        m_memberLoopModeChanged,
        arguments,
        argCount, 
        0, // A signal with a TTL of 0 will be sent to every member of the session, regardless of how long it takes to deliver the message
        ALLJOYN_MESSAGE_FLAG_GLOBAL_BROADCAST, // Broadcast to everyone in the session.
        NULL); // The generated code does not need the generated signal message

    alljoyn_msgarg_destroy(arguments);
}

void MediaPlayerSignals::CallLoopModeChangedReceived(_In_ MediaPlayerSignals^ sender, _In_ MediaPlayerLoopModeChangedReceivedEventArgs^ args)
{
    LoopModeChangedReceived(sender, args);
}

void MediaPlayerSignals::OnPlaybackError(_In_ int32 interfaceMemberIndex, _In_ Platform::String^ interfaceMemberError, _In_ Platform::String^ interfaceMemberDescription)
{
    if (nullptr == m_busObject)
    {
        return;
    }

    size_t argCount = 3;
    alljoyn_msgarg arguments = alljoyn_msgarg_array_create(argCount);
    (void)TypeConversionHelpers::SetAllJoynMessageArg(alljoyn_msgarg_array_element(arguments, 0), "i", interfaceMemberIndex);
    (void)TypeConversionHelpers::SetAllJoynMessageArg(alljoyn_msgarg_array_element(arguments, 1), "s", interfaceMemberError);
    (void)TypeConversionHelpers::SetAllJoynMessageArg(alljoyn_msgarg_array_element(arguments, 2), "s", interfaceMemberDescription);
    
    alljoyn_busobject_signal(
        m_busObject, 
        NULL,  // Generated code only supports broadcast signals.
        m_sessionId,
        m_memberOnPlaybackError,
        arguments,
        argCount, 
        0, // A signal with a TTL of 0 will be sent to every member of the session, regardless of how long it takes to deliver the message
        ALLJOYN_MESSAGE_FLAG_GLOBAL_BROADCAST, // Broadcast to everyone in the session.
        NULL); // The generated code does not need the generated signal message

    alljoyn_msgarg_destroy(arguments);
}

void MediaPlayerSignals::CallOnPlaybackErrorReceived(_In_ MediaPlayerSignals^ sender, _In_ MediaPlayerOnPlaybackErrorReceivedEventArgs^ args)
{
    OnPlaybackErrorReceived(sender, args);
}

void MediaPlayerSignals::PlaylistChanged()
{
    if (nullptr == m_busObject)
    {
        return;
    }

    size_t argCount = 0;
    alljoyn_msgarg arguments = alljoyn_msgarg_array_create(argCount);
    
    alljoyn_busobject_signal(
        m_busObject, 
        NULL,  // Generated code only supports broadcast signals.
        m_sessionId,
        m_memberPlaylistChanged,
        arguments,
        argCount, 
        0, // A signal with a TTL of 0 will be sent to every member of the session, regardless of how long it takes to deliver the message
        ALLJOYN_MESSAGE_FLAG_GLOBAL_BROADCAST, // Broadcast to everyone in the session.
        NULL); // The generated code does not need the generated signal message

    alljoyn_msgarg_destroy(arguments);
}

void MediaPlayerSignals::CallPlaylistChangedReceived(_In_ MediaPlayerSignals^ sender, _In_ MediaPlayerPlaylistChangedReceivedEventArgs^ args)
{
    PlaylistChangedReceived(sender, args);
}

void MediaPlayerSignals::ShuffleModeChanged(_In_ Platform::String^ interfaceMemberShuffleMode)
{
    if (nullptr == m_busObject)
    {
        return;
    }

    size_t argCount = 1;
    alljoyn_msgarg arguments = alljoyn_msgarg_array_create(argCount);
    (void)TypeConversionHelpers::SetAllJoynMessageArg(alljoyn_msgarg_array_element(arguments, 0), "s", interfaceMemberShuffleMode);
    
    alljoyn_busobject_signal(
        m_busObject, 
        NULL,  // Generated code only supports broadcast signals.
        m_sessionId,
        m_memberShuffleModeChanged,
        arguments,
        argCount, 
        0, // A signal with a TTL of 0 will be sent to every member of the session, regardless of how long it takes to deliver the message
        ALLJOYN_MESSAGE_FLAG_GLOBAL_BROADCAST, // Broadcast to everyone in the session.
        NULL); // The generated code does not need the generated signal message

    alljoyn_msgarg_destroy(arguments);
}

void MediaPlayerSignals::CallShuffleModeChangedReceived(_In_ MediaPlayerSignals^ sender, _In_ MediaPlayerShuffleModeChangedReceivedEventArgs^ args)
{
    ShuffleModeChangedReceived(sender, args);
}

